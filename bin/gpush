#!/bin/sh
#
# Copyright (C) 2008-2014  Etersoft
# Copyright (C) 2008-2014  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

PROGDIR=$(dirname $0)
[ "$PROGDIR" = "." ] && PROGDIR=$(pwd)

. $PROGDIR/giter-sh-functions

load_mod git

test -r "$1" && fatal "Do not need any files in params"

PUSHFORCE=
PUSHALL=
TAGSALL=
NEWGIRAR=

#############################
Usage="Usage: $name [GIRAR/remote alias] [-f|--force] [-a|--all] [-t|--tags] [tag]"
function mygetopts()
{
name=${0##*/}
Descr="$name - publish current project repo remote git repo"

phelp()
{
	echog "$Descr"
	echog "$Usage"
	echog "Options:"
	echog " -f - force push"
	echog " -a - push all branches"
	echog " -t - push all tags"
}

while getopts :hfat opt; do
    case $opt in
    h) phelp; exit 0;;
    f) PUSHFORCE="--force" ;;
    a) PUSHALL="--all" ;;
    t) TAGSALL="--tags" ;;
    +?) echog "$name: options should not be preceded by a '+'." 1>&2; exit 2;;
    ?) OPTIND=$((OPTIND-1)); break;
    esac
done

## remove args that were options
if [ $# -gt 0 ]; then
	shift $((OPTIND - 1))
fi

LISTARGS="$@"
#LISTARGS=$(drop_args "$*" f a t)

}

# Skip first param
if ! echo "$1" | grep -q "^-" ; then
    NEWGIRAR="$1"
    shift
fi

mygetopts $@


push_to_remote()
{
	local GHOST=$1
	local TEXTTAG=
	local PROJECTDIR=$(get_root_git_dir)

	[ -n "$TAGSALL$PUSHALL" ] && TEXTTAG="(with all tags)"

	echo
	echo "** Push $TEXTBRANCH from $PROJECTDIR to $GHOST $TEXTTAG"

	docmd git push $PUSHALL $PUSHFORCE $GHOST $CURRENTBRANCH || return
	if [ -n "$TAGSALL" ] ; then
		docmd git push --tags $GHOST $CURRENTBRANCH
	else
		if is_last_commit_tag ; then
			local LASTTAG=$(get_last_tag)
			if [ -n "$LASTTAG" ] ; then
				echo "*** Push last tag $LASTTAG"
				docmd git push $PUSHFORCE $GHOST $LASTTAG
			fi
		fi
	fi
}

tune_girarlist()
{

REMOTELIST="$(get_remote_git_list)"

if [ -z "$NEWGIRAR" ] ; then
	NEWGIRAR="$1"
	shift
fi

# If run with gear as param
if [ -n "$NEWGIRAR" ] ; then
	# if run with girar host in arg
	if is_girar_name "$NEWGIRAR" ; then
		# if remote list is empty, do ginit
		[ -n "$REMOTELIST" ] || ginit $NEWGIRAR
	fi
	LISTGIRARHOST="$NEWGIRAR"
else
	# use one target if it one
	if is_one_girar_name "$REMOTELIST" ; then
		GIRARHOST="$REMOTELIST"
	fi

	# origin by default if exists and alone
	if get_remote_repo_list | grep -q origin ; then
		GIRARHOST="origin"
	fi
	LISTGIRARHOST="$GIRARHOST $(do_exclude_list "$GIRARHOST" "$REMOTELIST")"
fi

# if set it can be tag or branch name
if [ -n "$1" ] ; then
	CURRENTBRANCH="$1"
	shift
else
	CURRENTBRANCH=$(get_current_branch)
fi

[ -n "$CURRENTBRANCH" ] || fatal "Can't detect current branch"

}

tune_girarlist $LISTARGS

if [ "$PUSHALL" = "--all" ] ; then
	TEXTBRANCH="all branches"
	CURRENTBRANCH=
else
	TEXTBRANCH="branch $CURRENTBRANCH"
	if git tag | grep -q "^$CURRENTBRANCH\$" ; then
		TEXTBRANCH="tag $CURRENTBRANCH"
	fi
fi

for i in $LISTGIRARHOST ; do
	push_to_remote $i
done
