#!/bin/sh
#
# Copyright (C) 2008-2014  Etersoft
# Copyright (C) 2008-2014  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

PROGDIR=$(dirname $0)
[ "$PROGDIR" = "." ] && PROGDIR=$(pwd)

. $PROGDIR/giter-common-functions
. $PROGDIR/giter-git-functions

test -r "$1" && fatal "Do not need any files in params"

PUSHFORCE=
PUSHALL=
TAGSALL=

#############################
Usage="Usage: $name [GIRAR/remote alias] [-f|--force] [-a|--all] [-b|--branches] [-t|--tags] [tag]"

mygetopts()
{
name=${0##*/}
Descr="$name - publish to remote git repository"

phelp()
{
	echo "$Descr"
	echo "$Usage"
	echo "Options:"
	echo " -f - force push"
	echo " -a - push to all remotes"
	echo " -b - push all branches"
	echo " -t - push all tags"
}

while getopts :hfat opt; do
    case $opt in
    h) phelp; exit 0;;
    f) PUSHFORCE="--force" ;;
    a) PUSHTOALL="--toall" ;;
    b) PUSHALLBRANCHES="--allbranches" ;;
    t) TAGSALL="--tags" ;;
    +?) echo "$name: options should not be preceded by a '+'." 1>&2; exit 2;;
    ?) OPTIND=$((OPTIND-1)); break;
    esac
done

## remove args that were options
if [ $# -gt 0 ]; then
	shift $((OPTIND - 1))
fi

LISTARGS="$@"
#LISTARGS=$(drop_args "$*" f a t)

}

FORCEGIRAR=
if force_work_hosts "$1" ; then
    # We have set host via first program arg
    FORCEGIRAR="$1"
    shift
fi

mygetopts $@


push_to_remote()
{
	local GHOST=$1
	local TEXTTAG=
	local PROJECTDIR=$(get_root_git_dir)

	[ -n "$TAGSALL" ] && TEXTTAG="(with all tags)"

	echo
	echo "** Push $TEXTBRANCH from $PROJECTDIR to $GHOST $TEXTTAG"

	docmd git push $PUSHALL $PUSHFORCE $GHOST $CURRENTBRANCH || return
	if [ -n "$TAGSALL" ] ; then
		docmd git push --tags $GHOST $CURRENTBRANCH
	else
		if is_last_commit_tag ; then
			local LASTTAG=$(get_last_tag)
			if [ -n "$LASTTAG" ] ; then
				echo "*** Push last tag $LASTTAG"
				docmd git push $PUSHFORCE $GHOST $LASTTAG
			fi
		fi
	fi
}

tune_girarlist()
{

REMOTELIST="$(get_remote_git_list)"

# If run with gear as param
if [ -n "$FORCEGIRAR" ] ; then
	# if remote list is empty, do ginit
	[ -n "$REMOTELIST" ] || ginit $GITHOST
	LISTGITHOST="$GITHOST"
else
        # TODO: bad way
	# origin by default if exists and alone
	#if get_remote_repo_list | grep -q origin ; then
	#	GITHOST="origin"
	#fi
	LISTGITHOST="$GITHOST $(do_exclude_list "$GITHOST" "$REMOTELIST")"
fi

if [ -n "$PUSHTOALL" ] ; then
       LISTGITHOST="$(get_remote_repo_list)"
fi

# if set it can be tag or branch name
if [ -n "$1" ] ; then
	CURRENTBRANCH="$1"
	shift
else
	CURRENTBRANCH=$(get_current_branch)
fi

[ -n "$CURRENTBRANCH" ] || fatal "Can't detect current branch"

}

tune_girarlist $LISTARGS

if [ "$PUSHALLBRANCHES" = "--allbranches" ] ; then
	TEXTBRANCH="all branches"
	CURRENTBRANCH=
else
	TEXTBRANCH="branch $CURRENTBRANCH"
	if git tag | grep -q "^$CURRENTBRANCH\$" ; then
		TEXTBRANCH="tag $CURRENTBRANCH"
	fi
fi

for i in $LISTGITHOST ; do
	push_to_remote $i
done
